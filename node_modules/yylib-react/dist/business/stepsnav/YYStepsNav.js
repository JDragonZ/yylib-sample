'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * 步骤条导航组件
 */
var React = require('react');

var _require = require('yylib-ui');

var YYClass = _require.YYClass;
var YYSteps = _require.YYSteps;
var YYStep = _require.YYStep;

var _require2 = require('react-dom');

var findDOMNode = _require2.findDOMNode;

var PropTypes = YYClass.PropTypes;
var field = YYClass.field;
var _ = require('lodash');
//定义META
var uiMeta = {
    name: 'stepsnav',
    fields: [
    // field参数列表：字段属性名|属性默认值|属性类型|是否必填|属性描述
    field('items', null, PropTypes.object, true, '步骤条数据来源{className:页面定位元素类名(唯一)，title:标题,description:详情描述}'), field('contextwidth', 80, PropTypes.number, false, '导航栏右侧宽度'), field('right', 0, PropTypes.number, false, '导航栏距离右侧窗口距离'), field('target', 'window', PropTypes.string, false, '设置导航栏需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数')]
};
var YYStepsNav = YYClass.create({
    uiMeta: uiMeta,
    getInitialState: function getInitialState() {
        return {
            current: 0,
            hasMove: false
        };
    },
    onscroll: function onscroll() {
        var _this = this;
        var toTopArr = [];
        var targetDom = this.getTargetDom();
        var scrolltop = targetDom.scrollTop;
        var _props = this.props;
        var items = _props.items;
        var children = _props.children;

        var items = items ? items : children;
        _.forEach(items, function (item) {
            var child = item.props ? item.props : item;
            var ele = document.getElementsByClassName(child.linkTarget)[0];
            if (ele) {
                var eletoTop = ele.getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;
                toTopArr.push(eletoTop);
            }
        });
        _.forEach(toTopArr, function (item, index) {
            var top = item - toTopArr[0] - targetDom.getBoundingClientRect().top;
            if (scrolltop >= top) {
                _this.setState({
                    current: index
                });
            }
        });
    },
    getTargetDom: function getTargetDom() {
        var target = this.props.target;
        var targetDom = null;
        if (target == 'window') {
            targetDom = document.body;
        } else {
            targetDom = document.getElementsByClassName(target)[0];
        }
        return targetDom;
    },
    componentDidMount: function componentDidMount() {
        var targetDom = this.getTargetDom();
        if (targetDom) {
            targetDom.addEventListener("mousewheel", this.onscroll);
        }
    },
    componentWillUnmount: function componentWillUnmount() {
        if (this.onscroll) {
            var targetDom = this.getTargetDom();
            targetDom.removeEventListener("mousewheel", this.onscroll);
        }
    },
    mouseIn: function mouseIn() {
        this.setState({
            hasMove: true
        });
    },
    mouseOut: function mouseOut() {
        this.setState({
            hasMove: false
        });
    },
    jumpTo: function jumpTo(key, anchor) {
        var top = 0;
        var targetDom = this.getTargetDom();
        if (anchor) {
            top = document.getElementsByClassName(anchor)[0].getBoundingClientRect().top + targetDom.scrollTop - targetDom.clientTop - targetDom.getBoundingClientRect().top;
        }
        targetDom.scrollTop = top;
        this.setState({
            current: key
        });
    },
    render: function render() {
        var _this = this;
        var minwidth = _this.props.right == 0 ? 45 : 42;
        var srcleft = 19;
        var contextwidth = this.props.contextwidth ? this.props.contextwidth : 80;
        var style = {
            borderRadius: '3px',
            padding: '15px 0px 0px 10px',
            border: '1px solid #dddddd',
            paddingTop: '20',
            marginLeft: this.state.hasMove ? srcleft - contextwidth + 'px' : srcleft + 'px',
            backgroundColor: 'white',
            right: this.props.right + 'px',
            width: this.state.hasMove ? minwidth + contextwidth + 'px' : minwidth + 'px',
            position: 'fixed',
            top: '25%',
            zIndex: '999'
        };
        var items = this.props.items;
        var hasMove = this.state.hasMove;
        var steps = [];
        var children = items ? items : this.props.children;
        _.forEach(children, function (child, index) {
            var props = child.props ? child.props : child;
            steps.push(React.createElement(YYStep, { title: React.createElement(
                    'span',
                    { onClick: _this.jumpTo.bind(null, index, props.linkTarget) },
                    hasMove ? props.title : ''
                ), description: hasMove ? props.description : '' }));
        });
        return React.createElement(
            'div',
            { className: this.className(),
                onMouseOver: this.mouseIn,
                onMouseOut: this.mouseOut,
                style: style },
            React.createElement(
                YYSteps,
                _extends({}, this.props, {
                    direction: 'vertical',
                    current: this.state.current
                }),
                steps
            )
        );
    }
});
module.exports = YYStepsNav;